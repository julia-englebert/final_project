---
title: "Maps"
author: "Julia Englebert"
date: "4/22/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(scipen = 999)

library(shiny)
library(haven)
library(tidyverse)
library(gt)
library(devtools)
library(tibble)
#library(foreign)
library(scales)
library(shinythemes)
library(plotly)
library(leaflet)
library(broom)
library(readxl)
library(gganimate)
library(patchwork)
library(magick)
library(webshot)
library(mapview)
# Probably not necessary
#webshot::install_phantomjs()

# packages for mapping
library(leaflet)
library(spdplyr)
library(rmapshaper)
library(sf)
```

# DATA WRANGLING

```{r allData, cache=TRUE}
# 1800s data

# Will comment on 1870s data, then repeat the process for all subsequent years
# Note that the codenames ARE DIFFERENT FOR EACH YEAR
# Even if the variable was measured in the same way
# See original codebook for details


# Read in all 1870 csv files
# Originally, R was returning this message:
# Column `STATE` joining factors with different levels, coercing to character vectorColumn `COUNTY` joining
# factors with different levels, coercing to character vector
# I got rid of it by converting all factors to characters

data1870a <- as_tibble(read.csv("raw-data/nhgis0002_csv/nhgis0002_ds16_1870_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1870b <- as_tibble(read.csv("raw-data/nhgis0002_csv/nhgis0002_ds17_1870_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

# Join the two datasets by STATEA and COUNTYA, which are the state and county codes

data1870j <- full_join(data1870a, data1870b, by = c("STATEA", "COUNTYA")) %>%
  
  # Mutate to get rid of the .x suffix on variables
  
  mutate(GISJOIN = GISJOIN.x, YEAR = YEAR.x, STATE = STATE.x, COUNTY = COUNTY.x) %>%
  
  # Mutate to rename varialbes of interest to uniform, comprehensible names
  # Some existing varialbes are combined to create the desired variables
  # See codebook
  
  mutate(value_farm = AJV001, n_farm = AJS001, cows =  AJ0003+AJ0005, horses = AJ0001, 
         avg_size = (AJT001*2 + AJT002*6 + AJT003*15 + AJT004*35 + AJT005*75 + AJT006*300 + AJT007*750 + 
                       AJT008*1200)/AKP001, value_implements = AKL001, pop = AJ3001, male = AKD001, 
         female = AKD002, enrolled = ALG001, urban_pop = AKE001, pct_urban = AKE001/AJ3001*100, 
         illiterate = AJ7001, acres_farms = AJU001+ AJU002+AJU003, 
         
         # Even though irrigation data doesn't exist for this year, I'm filling the columns in with NA
         # Later years will have irrigation data
         
         acres_irrigated = NA, pct_irrigated = NA) %>%
  
  # Mutate again to make new variables out of the ones you just created in the last mutate
  
  mutate(cows_per_person = cows/n_farm, pct_enrolled = enrolled/pop*100, pct_illiterate = illiterate/pop*100) %>%
  
  # Select the desired variables
  
  select(STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, value_farm, value_implements, avg_size, n_farm,
         acres_farms, acres_irrigated, pct_irrigated, cows, cows_per_person, horses, pop, male, female,
         enrolled, pct_enrolled, urban_pop, pct_urban, illiterate, pct_illiterate)

# Now the dataset is much more manageable!

# Start on the next year, 1880, repeating the exact same process
# Lots of NA values due to scant data this year

data1880a <- as_tibble(read.csv("raw-data/nhgis0002_csv/nhgis0002_ds22_1880_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1880b <- as_tibble(read.csv("raw-data/nhgis0002_csv/nhgis0002_ds23_1880_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1880j <- full_join(data1880a, data1880b, by = c("STATEA", "COUNTYA")) %>%
  mutate(GISJOIN = GISJOIN.x, YEAR = YEAR.x, STATE = STATE.x, COUNTY = COUNTY.x) %>%
  mutate(value_farm = APN001+APO001+APQ001, n_farm = AOQ001, cows =  AOG004+AOG005, horses = AOG001, value_implements = APO001, pop = AOT001, male = AP1001, female = AP1002, 
         enrolled = NA, urban_pop = AO4001, pct_urban = AO4001/AOT001*100, illiterate = NA, 
         acres_farms = AOR001, acres_irrigated = NA, pct_irrigated = NA) %>%
  mutate(avg_size = acres_farms/n_farm, cows_per_person = cows/n_farm, pct_enrolled = enrolled/pop*100, pct_illiterate = illiterate/pop*100) %>%
  select(STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, value_farm, value_implements, avg_size, n_farm, 
         acres_farms, acres_irrigated, pct_irrigated, cows, cows_per_person, horses, pop, male, female, 
         enrolled, pct_enrolled, urban_pop, pct_urban, illiterate, pct_illiterate)

# Start on 1890 data

data1890a <- as_tibble(read.csv("raw-data/nhgis0002_csv/nhgis0002_ds26_1890_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1890b <- as_tibble(read.csv("raw-data/nhgis0002_csv/nhgis0002_ds27_1890_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1890j <- full_join(data1890a, data1890b, by = c("STATEA", "COUNTYA")) %>%
  mutate(GISJOIN = GISJOIN.x, YEAR = YEAR.x, STATE = STATE.x, COUNTY = COUNTY.x) %>%
  mutate(value_farm = AUK001+AUK002+AUK003, n_farm = AS9001, cows = ASY002, horses = ASY003, value_implements = AUK002, pop = AUM001, male = AV0001+AV0003+AV0005+AV0007, 
         female = AV0002+AV0004+AV0006+AV0008, enrolled = AVK005+AVK006+AVK007+AVK008, urban_pop = AUU001, 
         pct_urban = AUU001/AUM001*100, illiterate = NA, acres_farms = AUJ001+AUJ002, 
         acres_irrigated = AT2001, pct_irrigated = AT2001/(AUJ001+AUJ002)*100) %>%
  mutate(avg_size = acres_farms/n_farm, cows_per_person = cows/n_farm, pct_enrolled = enrolled/pop*100, pct_illiterate = illiterate/pop*100) %>%
  select(STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, value_farm, value_implements, avg_size, n_farm, 
         acres_farms, acres_irrigated, pct_irrigated, cows, cows_per_person, horses, pop, male, female, 
         enrolled, pct_enrolled, urban_pop, pct_urban, illiterate, pct_illiterate)

# Before I mutated all of the data, running this code showed that all .x values are the same 
# as all .y values, so it was safe to eliminate the double columns as long as "problems" returned 0
# And it did!
  
#problems <- bind_rows(data1870j, data1880j, data1890j) %>% 
  #select(STATEA, COUNTYA, GISJOIN.x, GISJOIN.y, YEAR.x, YEAR.y, STATE.x, STATE.y, 
         #COUNTY.x, COUNTY.y, AREANAME.x, AREANAME.y) %>%
  #mutate(same = ifelse(GISJOIN.x == GISJOIN.y & YEAR.x == YEAR.y & STATE.x == STATE.y & 
                         #COUNTY.x == COUNTY.y & AREANAME.x == AREANAME.y, TRUE, FALSE)) %>%
  #filter(same == "FALSE") %>%
  #nrow()



# Read in the 1900s data

# Only do decennial census data
# Intermittent years only have AF12001: estimated population

# 1900

data1900a <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds30_1900_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1900b <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds31_1900_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1900j <- full_join(data1900a, data1900b, by = c("STATEA", "COUNTYA")) %>%
  mutate(GISJOIN = GISJOIN.x, YEAR = YEAR.x, STATE = STATE.x, COUNTY = COUNTY.x) %>%
  mutate(value_farm = AWV001, n_farm = AW3001, cows = AW7001, horses = AW7002, value_implements = AWW003, pop = AWS001, male = AZ0001,female = AZ0001, 
         enrolled = NA, urban_pop = NA, pct_urban = NA, illiterate = AYS001+AYS002+AYS003+AYS004+AYS005, 
         acres_farms = AWT001, acres_irrigated = AX8001, pct_irrigated = AX8001/AWT001*100) %>%
  mutate(avg_size = acres_farms/n_farm, cows_per_person = cows/n_farm, pct_enrolled = enrolled/pop*100, pct_illiterate = illiterate/pop*100) %>%
  select(STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, value_farm, value_implements, avg_size, n_farm, 
         acres_farms, acres_irrigated, pct_irrigated, cows, cows_per_person, horses, pop, male, female, 
         enrolled, pct_enrolled, urban_pop, pct_urban, illiterate, pct_illiterate)

# 1910

data1910a <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds36_1910_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1910b <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds37_1910_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1910j <- full_join(data1910a, data1910b, by = c("STATEA", "COUNTYA")) %>%
  mutate(GISJOIN = GISJOIN.x, YEAR = YEAR.x, STATE = STATE.x, COUNTY = COUNTY.x) %>%
  mutate(value_farm = A0F001, n_farm = A1H001, cows = A1F001+A1F002, horses = NA, 
         avg_size = A21001/A1H001, value_implements = A0Q005, pop = A0E001, male = NA, female = NA, 
         enrolled = A4F001, urban_pop = A36001, pct_urban = A36001/A0E001*100, illiterate = A38001, 
         acres_farms = A21001, acres_irrigated = A0G001, pct_irrigated = A0G001/A21001*100) %>%
  mutate(cows_per_person = cows/n_farm, pct_enrolled = enrolled/pop*100, pct_illiterate = illiterate/pop*100) %>%
  select(STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, value_farm, value_implements, avg_size, n_farm, 
         acres_farms, acres_irrigated, pct_irrigated, cows, cows_per_person, horses, pop, male, female, 
         enrolled, pct_enrolled, urban_pop, pct_urban, illiterate, pct_illiterate)

#1920
  
data1920a <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds43_1920_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME =  as.character(AREANAME))

data1920b <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds224_1920_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1920c <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds210_1920_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1920j <- full_join(data1920a, data1920b, by = c("STATEA", "COUNTYA"))
data1920j <- full_join(data1920j, data1920c, by = c("STATEA", "COUNTYA"))
data1920j <- data1920j %>%
  mutate(GISJOIN = GISJOIN.x, YEAR = YEAR.x, STATE = STATE.x, COUNTY = COUNTY.x) %>%
  mutate(value_farm = A8P001+A8P002+A8P003+A8P004, n_farm = AB3P001, cows = NA, horses = NA, 
         avg_size = AB3T001/AB3P001, value_implements = A8P003, pop = A81001, male = A8B001, 
         female = A8B002, enrolled = A7N001+A7N002+A7N003+A7N004, urban_pop = A80001, 
         pct_urban = A80001/A81001*100, illiterate = A7U001, acres_farms = AB3T001, 
         acres_irrigated = AB6L001, pct_irrigated = AB6L002/AB3T001*100) %>%
  mutate(cows_per_person = cows/n_farm, pct_enrolled = enrolled/pop*100, pct_illiterate = illiterate/pop*100) %>%
  select(STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, value_farm, value_implements, avg_size, n_farm, 
         acres_farms, acres_irrigated, pct_irrigated, cows, cows_per_person, horses, pop, male, female, 
         enrolled, pct_enrolled, urban_pop, pct_urban, illiterate, pct_illiterate)

#1930
# 1930 has more datasets available than previous years

data1930a <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds212_1930_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1930b <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds224_1930_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1930c <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds52_1930_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1930d <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds53_1930_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1930e <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds54_1930_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1930f <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds55_1930_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1930j <- full_join(data1930a, data1930b, by = c("STATEA", "COUNTYA"))
data1930j <- full_join(data1930j, data1930c, by = c("STATEA", "COUNTYA"))
data1930j <- full_join(data1930j, data1930d, by = c("STATEA", "COUNTYA"))
data1930j <- full_join(data1930j, data1930e, by = c("STATEA", "COUNTYA"))
data1930j <- full_join(data1930j, data1930f, by = c("STATEA", "COUNTYA"))

data1930j <- data1930j %>%
  mutate(GISJOIN = GISJOIN.x, YEAR = YEAR.x, STATE = STATE.x, COUNTY = COUNTY.x) %>%
  mutate(value_farm = BFD001+BFD002+BFD004+ACEO001, n_farm = AB95001, cows = NA, horses = NA, value_implements = BFD004, pop = BCX001, male = BC3001, 
         female = BC3002, enrolled = BDT001+BDT002+BDT003+BDT004, urban_pop = BDX001, 
         pct_urban = BDX001/BDP001*100, illiterate = BDV001, acres_farms = AB98001, 
         acres_irrigated = ACEX002, pct_irrigated = ACEX002/AB98001*100) %>%
  mutate(avg_size = acres_farms/n_farm, cows_per_person = cows/n_farm, pct_enrolled = enrolled/pop*100, pct_illiterate = illiterate/pop*100) %>%
  select(STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, value_farm, value_implements, avg_size, n_farm, 
         acres_farms, acres_irrigated, pct_irrigated, cows, cows_per_person, horses, pop, male, female, 
         enrolled, pct_enrolled, urban_pop, pct_urban, illiterate, pct_illiterate)

# 1940

data1940a <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds224_1940_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1940b <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds77_1940_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1940c <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds78_1940_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1940j <- full_join(data1940a, data1940b, by = c("STATEA", "COUNTYA"))
data1940j <- full_join(data1940j, data1940c, by = c("STATEA", "COUNTYA"))
data1940j <- data1940j %>%
  mutate(GISJOIN = GISJOIN.x, YEAR = YEAR.x, STATE = STATE.x, COUNTY = COUNTY.x) %>%
  
  # value_farm is missing the land & livestock components!!
  # this variable only includings buildings and implements
  
  mutate(value_farm = BWD001+BWD002, n_farm = BY1001, cows = NA, horses = NA, value_implements = BWD002, pop = BVU001, male = BVY001, 
         female = BVY002, enrolled = BWU001+BWU002+BWU003+BWU004+BWU005, urban_pop = NA, 
         pct_urban = NA, illiterate = NA, acres_farms = BY3001, 
         acres_irrigated = NA, pct_irrigated = NA) %>%
  mutate(avg_size = acres_farms/n_farm, cows_per_person = cows/n_farm, pct_enrolled = enrolled/pop*100, 
         pct_illiterate = illiterate/pop*100) %>%
  select(STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, value_farm, value_implements, avg_size, n_farm, 
         acres_farms, acres_irrigated, pct_irrigated, cows, cows_per_person, horses, pop, male, female, 
         enrolled, pct_enrolled, urban_pop, pct_urban, illiterate, pct_illiterate)

# 1950

data1950a <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds83_1950_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME =  as.character(AREANAME))

data1950b <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds84_1950_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1950j <- full_join(data1950a, data1950b, by = c("STATEA", "COUNTYA")) %>%
  mutate(GISJOIN = GISJOIN.x, YEAR = YEAR.x, STATE = STATE.x, COUNTY = COUNTY.x, 
         B18001 = as.numeric(B18001)) %>%
  
  # value_farm is missing the implements & livestock components!!
  # This variable only includings buildings and land
  
  mutate(value_farm = B3M001, n_farm = B3Z001, cows = NA, horses = NA, value_implements = NA, pop = B13001, male = B3E001, 
         female = B3E002, enrolled = B2A001+B2A002+B2A003+B2A004+B2A005, urban_pop = B2J001, 
         pct_urban = B2J001/B13001*100, illiterate = NA, acres_farms = B3K001, 
         acres_irrigated = NA, pct_irrigated = NA) %>%
  mutate(avg_size = acres_farms/n_farm, cows_per_person = cows/n_farm, pct_enrolled = enrolled/pop*100, pct_illiterate = illiterate/pop*100) %>%
  select(STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, value_farm, value_implements, avg_size, n_farm, 
         acres_farms, acres_irrigated, pct_irrigated, cows, cows_per_person, horses, pop, male, female, 
         enrolled, pct_enrolled, urban_pop, pct_urban, illiterate, pct_illiterate)

#1960
# The data are SPARSE yikes

data1960a <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds89_1960_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME =  as.character(AREANAME))

data1960b <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds90_1960_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1960c <- as_tibble(read.csv("raw-data/nhgis0003_csv/nhgis0003_ds91_1960_county.csv")) %>%
  mutate(GISJOIN = as.character(GISJOIN), STATE = as.character(STATE), COUNTY = as.character(COUNTY), 
         AREANAME = as.character(AREANAME))

data1960j <- full_join(data1960a, data1960b, by = c("STATEA", "COUNTYA"))
data1960j <- full_join(data1960j, data1960c, by = c("STATEA", "COUNTYA"))
data1960j <- data1960j %>%
  mutate(value_farm = NA, n_farm = NA, cows = NA, horses = NA, 
         avg_size = NA, value_implements = NA, pop = B47001, male = B5H001, 
         female = B5H002, enrolled = NA, urban_pop = NA, pct_urban = NA, illiterate = NA, 
         acres_farms = NA, acres_irrigated = NA, pct_irrigated = NA) %>%
  mutate(cows_per_person = cows/n_farm, pct_enrolled = enrolled/pop*100, pct_illiterate = illiterate/pop*100) %>%
  select(STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, value_farm, value_implements, avg_size, n_farm, 
         acres_farms, acres_irrigated, pct_irrigated, cows, cows_per_person, horses, pop, male, female, 
         enrolled, pct_enrolled, urban_pop, pct_urban, illiterate, pct_illiterate)

```

## Join the cleaned sets

```{r boundData, cache=TRUE}
# Running this code (before I renamed variables) showed that all .x values are the same as all .y values, 
# so it was safe to eliminate the double columns
# as long as problems returned 0 (and it did!)
# this didn't check for .x.x or .y.x. columns, etc.
  
#problems <- bind_rows(data1900j, data1910j, data1920j, data1930j, data1940j, data1950j, data1960j) %>% 
  #select(STATEA, COUNTYA, GISJOIN.x, GISJOIN.y, YEAR.x, YEAR.y, STATE.x, STATE.y, 
         #COUNTY.x, COUNTY.y) %>%
  #mutate(same = ifelse(GISJOIN.x == GISJOIN.y & YEAR.x == YEAR.y & STATE.x == STATE.y & 
                         #COUNTY.x == COUNTY.y, TRUE, FALSE)) %>%
  #filter(same == "FALSE") %>%
  #nrow()

  
# Now bind all of the years together!
# Add pct_male and avg_value_farm variables
# Filter for only midwestern states/territories

allData_inflated <- as_tibble(bind_rows(data1870j, data1880j, data1890j, 
                       data1900j, data1910j, data1920j, data1930j, data1940j, data1950j, data1960j)) %>%
  mutate(pct_male = male/pop*100, avg_value_farm = value_farm/n_farm, cows_per_farm = cows_per_person, avg_value_implements = value_implements/n_farm, 
         pct_urban = ifelse(pct_urban > 100, NA, pct_urban)) %>%
  
  # I mislabeled cows_per_farm as cows_per_person, so I'm doing damage control now
  
  select(!cows_per_person) %>%
  filter(STATE == "North Dakota" | STATE == "South Dakota" | STATE == "Dakota Territory" | 
           STATE == "Nebraska" | STATE == "Minnesota" | STATE == "Iowa" | STATE == "Missouri" | 
           STATE == "Wisconsin" | STATE == "Illinois" | STATE == "Kansas" | STATE == "Michigan" | 
           STATE == "Indiana" | STATE == "Ohio", 
         
         # Get rid of the weird infinite values in this column 
         
         ! is.infinite(cows_per_farm))

# Now adjust everything for inflation
# I made a spreadsheet based on this website: 
# https://www.officialdata.org/us/inflation/1960?amount=1

inflation <- read_excel("inflation.xlsx")

clean_data <- left_join(allData_inflated, inflation, by = c("YEAR" = "year")) %>%
  # Use the multiplier column to adjust for inflation
  mutate(value_farm = value_farm*multiplier, value_implements = value_implements*multiplier) %>%
  mutate(avg_value_farm = value_farm/n_farm, avg_value_implements = value_implements/n_farm) 

# Now save as an RDS file to save on space

# saveRDS(clean_data, file = "final/my_data.rds")
saveRDS(clean_data, file = "my_data.rds")
saveRDS(clean_data, file = "testing123/my_data.rds")


```

```{r mapDataset, cache=TRUE}

# Now just read in the RDS file
# This is all you need to copy into the shiny app

allData <- readRDS(file = "my_data.rds")

# this is workable data, where NA columns have been removed
# There was too much variable variation & inconsistencies to draw conclusions from all years

subData <- allData %>% 
  filter(YEAR == "1870" | YEAR == "1890" | YEAR == "1910") %>%
  select(-acres_irrigated, -pct_irrigated, -illiterate, -pct_illiterate, -male, -female, -pct_male)



# This next bitwill be used for mapping only!
# All relevant columns must be numeric in order to function properly
# Renaming them also helps make the maps more easily interpretable
# But it's not ideal for working with the data in other contexts, hence the separate set

mwData <- allData %>%
  mutate("Value of Farms" = as.numeric(value_farm), "Average Farm Value" = as.numeric(avg_value_farm), 
         "Value of Implements" = as.numeric(value_implements), 
         "Average Implement Value" = as.numeric(avg_value_implements), 
         "Average Farm Size" = as.numeric(avg_size), "Number of Farms" = as.numeric(n_farm), 
         "Acres of Farmland" = as.numeric(acres_farms), "Irrigated Acres" = as.numeric(acres_irrigated), 
         "Percentage of Farmland Irrigated" = as.numeric(pct_irrigated), "Number of Cows" = as.numeric(cows),
         "Number of Cows per Farm" = as.numeric(cows_per_farm), "Number of Horses" = as.numeric(horses), 
         "Total Population" = as.numeric(pop), "Male Population" = as.numeric(male), 
         "Female Population" = as.numeric(female), "Male Percentage of Population" = as.numeric(pct_male),
         "Total School Enrollment" = as.numeric(enrolled), 
         "Percentage School Enrollment" = as.numeric(pct_enrolled), 
         "Urban Population" = as.numeric(urban_pop), 
         "Percent of Population in Urban Areas" = as.numeric(pct_urban), 
         "Illiterate Population" = as.numeric(illiterate), 
         "Illiteracy Rate" = as.numeric(pct_illiterate)) %>%
  select(STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, 
         "Value of Farms", "Average Farm Value", "Value of Implements", "Average Implement Value",
                   "Average Farm Size", "Number of Farms", "Acres of Farmland", "Irrigated Acres", 
                   "Percentage of Farmland Irrigated", "Number of Cows", "Number of Cows per Farm", 
                   "Number of Horses", "Total Population", "Male Population", "Female Population", 
                   "Male Percentage of Population", "Total School Enrollment", 
                   "Percentage School Enrollment", "Urban Population", 
                   "Percent of Population in Urban Areas", "Illiterate Population", "Illiteracy Rate")

# saving this for later
# will need in shiny app
#sliderOptions <- c("Value of Farms", "Average Farm Value", "Value of Implements", "Average Implement Value",
                   #"Average Farm Size", "Number of Farms", "Acres of Farmland", "Irrigated Acres", 
                   #"Percentage of Farmland Irrigated", "Number of Cows", "Number of Cows per Farm", 
                   #"Number of Horses", "Total Population", "Male Population", "Female Population", 
                   #"Male Percentage of Population", "Total School Enrollment", 
                   #"Percentage School Enrollment", "Urban Population", 
                   #"Percent of Population in Urban Areas", "Illiterate Population", "Illiteracy Rate")

#saveRDS(mwData, file = "final/mwData.rds")
  
```

# Shiny 
## Preparation

```{r shapefiles, cache=TRUE}

# Now save the gis data with short names for sake of the shiny app
# hopefully this will work...

# I had to shorten the file paths in order to deploy my app
# The maps can no longer render in this directory as a result
dsn1870 <- "raw-data/nhgis0002_shape/nhgis0002_shapefile_tl2008_us_county_1870"
  layer1870 <- "US_county_1870_conflated"
dsn1880 <- "raw-data/nhgis0002_shape/nhgis0002_shapefile_tl2008_us_county_1880"
  layer1880 <- "US_county_1880_conflated"
dsn1890 <- "raw-data/nhgis0002_shape/nhgis0002_shapefile_tl2008_us_county_1890"
layer1890 <- "US_county_1890_conflated"

dsn1900 <- "raw-data/nhgis0003_shape/nhgis0003_shapefile_tl2008_us_county_1900"
  layer1900 <- "US_county_1900_conflated"
dsn1910 <- "raw-data/nhgis0003_shape/nhgis0003_shapefile_tl2008_us_county_1910"
  layer1910 <- "US_county_1910_conflated"
dsn1920 <- "raw-data/nhgis0003_shape/nhgis0003_shapefile_tl2008_us_county_1920"
  layer1920 <- "US_county_1920_conflated"
dsn1930 <- "raw-data/nhgis0003_shape/nhgis0003_shapefile_tl2008_us_county_1930"
  layer1930 <- "US_county_1930_conflated"
dsn1940 <- "raw-data/nhgis0003_shape/nhgis0003_shapefile_tl2008_us_county_1940"
  layer1940 <- "US_county_1940_conflated"
dsn1950 <- "raw-data/nhgis0003_shape/nhgis0003_shapefile_tl2008_us_county_1950"
  layer1950 <- "US_county_1950_conflated"
dsn1960 <- "raw-data/nhgis0003_shape/nhgis0003_shapefile_tl2008_us_county_1960"
  layer1960 <- "US_county_1960_conflated"

# Make a tibble of all the shapefiles that you'll need
  shapefiles <- tibble(Year = c(1870, 1880, 1890, 1900, 1910, 1920, 1930, 1940, 1950, 1960), 
                     Dsn = c(dsn1870, dsn1880, dsn1890, dsn1900, dsn1910, dsn1920, dsn1930, 
                             dsn1940, dsn1950, dsn1960),
                     Layer = c(layer1870, layer1880, layer1890, layer1900, layer1910, layer1920, 
                     layer1930, layer1940, layer1950, layer1960))
  

#saveRDS(shapefiles, file = "final/shapefiles.rds")
```

## Output
### Final
#### Change

```{r gisTemplate, cache=TRUE}
# might also want to add a filter for state??
# if time permits...

# gis template for any year/variable desired
# only change these two lines!
year <- 1870

#choices for myvar will be determined by: 
appPlan <- mwData %>%
  filter(YEAR == year) %>%
  select_if(~ !all(is.na(.))) %>%
  select(-STATEA:-COUNTY)

# myvar options will be determined by column names of appPlan & displayed via dropdown widget
myvar <- "Average Implement Value"

datayear <- mwData %>%
  # use get() to use the stored variable
  # idk why, but it doesn't work without this
  # the variable must be converted to a double in the original mwData dataset
  mutate(myvariable = (get(myvar))) %>%
  filter(YEAR == year, myvariable > 0) %>%
  select(GISJOIN, myvariable)

# Import Census Tract Shapefile into R as SpatialPolygonsDataFrameFormat (SP Dataframe)
# dsn is location of folder which contains shapefiles, (.proj, .shp etc.)
# layer is the filename of the .shp file inside the
# folder dsn points to. 

dsnyear <- shapefiles %>% 
  filter(Year == year) %>% 
  pull(Dsn)
layeryear <- shapefiles %>% 
  filter(Year == year) %>% 
  pull(Layer)

countyyear <- sf::st_read(dsn = dsnyear,
                         layer = layeryear)

countyyear <-
  countyyear %>%
  merge(datayear, "GISJOIN")


# Set projection of tracts dataset to `projection` required by leaflet

countyyear <- sf::st_transform(countyyear, crs="+init=epsg:4326")

# Condense size of data for faster processing

#countyyear <- rmapshaper::ms_simplify(countyyear)

# Set palette color

pal <- colorNumeric("viridis", NULL)

#  Plot the data

# use shiny to add a title, which will be be equivalent to myvar

leaflet(countyyear) %>%
  addTiles() %>%
  addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 1,
              fillColor = ~pal(myvariable)) %>%
  #setView(-87.4290, 43, zoom = 6) %>%
  addLegend(pal = pal, values = ~myvariable, opacity = 1.0, title = myvar)

```

```{r}
# Saving maps as pngs
# Since I couldn't get my interactive maps to run on shiny, this is the supremely disappointing 
# work-around

## 'leaflet' objects (image above)

# mapshot(enroll_1870, file = "enroll_1870.png")

# This initially worked, but then R started crashing every time I tried to run it
# Now I'm resorting to sCreEnsHotS

```

# SCREENSHOT Section
# Delete later

```{r}
year <- 1880

#choices for myvar will be determined by: 
appPlan <- mwData %>%
  filter(YEAR == year) %>%
  select_if(~ !all(is.na(.))) %>%
  select(-STATEA:-COUNTY)

# myvar options will be determined by column names of appPlan & displayed via dropdown widget
myvar <- "Average Implement Value"

datayear <- mwData %>%
  # use get() to use the stored variable
  # idk why, but it doesn't work without this
  # the variable must be converted to a double in the original mwData dataset
  mutate(myvariable = (get(myvar))) %>%
  filter(YEAR == year, myvariable > 0) %>%
  select(GISJOIN, myvariable)

# Import Census Tract Shapefile into R as SpatialPolygonsDataFrameFormat (SP Dataframe)
# dsn is location of folder which contains shapefiles, (.proj, .shp etc.)
# layer is the filename of the .shp file inside the
# folder dsn points to. 

dsnyear <- shapefiles %>% 
  filter(Year == year) %>% 
  pull(Dsn)
layeryear <- shapefiles %>% 
  filter(Year == year) %>% 
  pull(Layer)

countyyear <- sf::st_read(dsn = dsnyear,
                         layer = layeryear)

countyyear <-
  countyyear %>%
  merge(datayear, "GISJOIN")


# Set projection of tracts dataset to `projection` required by leaflet

countyyear <- sf::st_transform(countyyear, crs="+init=epsg:4326")

# Condense size of data for faster processing

#countyyear <- rmapshaper::ms_simplify(countyyear)

# Set palette color

pal <- colorNumeric("viridis", NULL)

#  Plot the data

# use shiny to add a title, which will be be equivalent to myvar

leaflet(countyyear) %>%
  addTiles() %>%
  addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 1,
              fillColor = ~pal(myvariable)) %>%
  #setView(-87.4290, 43, zoom = 6) %>%
  addLegend(pal = pal, values = ~myvariable, opacity = 1.0, title = myvar)
```


```{r}
year <- 1890


# myvar options will be determined by column names of appPlan & displayed via dropdown widget
myvar <- "Average Implement Value"

datayear <- mwData %>%
  # use get() to use the stored variable
  # idk why, but it doesn't work without this
  # the variable must be converted to a double in the original mwData dataset
  mutate(myvariable = (get(myvar))) %>%
  filter(YEAR == year, myvariable > 0) %>%
  select(GISJOIN, myvariable)

# Import Census Tract Shapefile into R as SpatialPolygonsDataFrameFormat (SP Dataframe)
# dsn is location of folder which contains shapefiles, (.proj, .shp etc.)
# layer is the filename of the .shp file inside the
# folder dsn points to. 

dsnyear <- shapefiles %>% 
  filter(Year == year) %>% 
  pull(Dsn)
layeryear <- shapefiles %>% 
  filter(Year == year) %>% 
  pull(Layer)

countyyear <- sf::st_read(dsn = dsnyear,
                         layer = layeryear)

countyyear <-
  countyyear %>%
  merge(datayear, "GISJOIN")


# Set projection of tracts dataset to `projection` required by leaflet

countyyear <- sf::st_transform(countyyear, crs="+init=epsg:4326")

# Condense size of data for faster processing

#countyyear <- rmapshaper::ms_simplify(countyyear)

# Set palette color

pal <- colorNumeric("viridis", NULL)

#  Plot the data

# use shiny to add a title, which will be be equivalent to myvar

leaflet(countyyear) %>%
  addTiles() %>%
  addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 1,
              fillColor = ~pal(myvariable)) %>%
  #setView(-87.4290, 43, zoom = 6) %>%
  addLegend(pal = pal, values = ~myvariable, opacity = 1.0, title = myvar)
```





```{r experimentalModels, cache = TRUE}

# INCORPORATE ALL OF THESE IN SHINY

# Incorporate
# Value of implements functions as a stand in for mechanization
impedu_plot <- allData %>%
  mutate(YEAR = as.factor(YEAR)) %>%
  group_by(YEAR) %>%
  select(YEAR, avg_value_implements, pct_enrolled) %>%
  na.omit() %>%
  ggplot(aes(x = avg_value_implements, y = pct_enrolled, color = YEAR)) + 
  geom_point(alpha = 0.1) +
  geom_smooth(method = "lm", se = FALSE) +
  scale_fill_viridis_d(aesthetics = "color") +
  ylim(0, 45) + 
  labs(title = "Relationship Between Farm Implements and Education, by County",
       subtitle = "Midwestern United States", 
       x = "Average Value of Implements", 
       y = "Percent Population Enrolled in School") +
  scale_x_log10(labels = comma) +
  theme_classic()

#ggsave("final/impedu_plot.png", plot = impedu_plot)

# See implement plot (plot2) saved as gif
# also use cowedu model


# INCORPORATE
# having more farms and being male leads to lower school enrollment
# supports my hypothesis of farm work affecting enrollment, since males might be expected to due more manual labor
maleedu_model <- allData %>%
  select(YEAR, pct_enrolled, n_farm, pct_male) %>%
  na.omit() %>%
  group_by(YEAR) %>%
  nest() %>%

  # Call map inside of mutate to add new columns to the tibble
  # upper and lower are the upper and lower bounds of the confidence interval created by tidy()
  
  # options
  #STATEA, COUNTYA, GISJOIN, YEAR, STATE, COUNTY, value_farm, value_implements, avg_size, n_farm, 
         # acres_farms, acres_irrigated, pct_irrigated, cows, cows_per_farm, horses, pop, male, female, 
        # enrolled, pct_enrolled, urban_pop, pct_urban, illiterate, pct_illiterate

  mutate(mod = map(data, ~ lm(pct_enrolled ~ n_farm*pct_male, data = .)),
         reg_results = map(mod, ~ tidy(., conf.int = TRUE)),
         n_farm_coef = map_dbl(reg_results, ~ filter(., term == "n_farm") %>% 
                                   pull(estimate)),
         n_farm_upper = map_dbl(reg_results, ~ filter(., term == "n_farm") %>% 
                                    pull(conf.high)),
         n_farm_lower = map_dbl(reg_results, ~ filter(., term == "n_farm") %>% 
                                    pull(conf.low)),
         pct_male_coef = map_dbl(reg_results, ~ filter(., term == "pct_male") %>% 
                                   pull(estimate)),
         pct_male_upper = map_dbl(reg_results, ~ filter(., term == "pct_male") %>% 
                                    pull(conf.high)),
         pct_male_lower = map_dbl(reg_results, ~ filter(., term == "pct_male") %>% 
                                    pull(conf.low)),
         interaction_coef = map_dbl(reg_results, ~ filter(., term == "n_farm:pct_male") %>% 
                                   pull(estimate)),
         interaction_upper = map_dbl(reg_results, ~ filter(., term == "n_farm:pct_male") %>% 
                                    pull(conf.high)),
         interaction_lower = map_dbl(reg_results, ~ filter(., term == "n_farm:pct_male") %>% 
                                    pull(conf.low))
         )

#saveRDS(maleedu_model, file = "final/maleedu_model.rds")

# Incorporate
maleedu_gt <- maleedu_model %>%
  ungroup() %>%
  
  # Select the columns needed, as per the instructions
  
  select(-data:-reg_results) %>%
  
  gt() %>%
  
  # Add the desired titles, subtitles, and column labels
  
  tab_header(title = "Effect of Gender and Number of Farms on Enrollment",
             subtitle = "With 95% Confidence Interval") %>%
  tab_spanner(label = "Farm Coefficients", columns = vars(n_farm_lower, n_farm_coef, n_farm_upper)) %>%
  tab_spanner(label = "Percent Male Coefficients", columns = vars(pct_male_lower, pct_male_coef,pct_male_upper)) %>%
  tab_spanner(label = "Interaction Coefficients", columns = vars(interaction_lower, interaction_coef, interaction_upper)) %>%
  cols_label(YEAR = "Year", n_farm_coef	= "Estimate", n_farm_upper = "Upper", n_farm_lower = "Lower", pct_male_coef = "Estimate", pct_male_upper = "Upper", pct_male_lower = "Lower",	interaction_coef = "Estimate", interaction_upper = "Upper", interaction_lower = "Lower") %>%
  # Round all values to two decimal places
  
  fmt_number(columns = vars(n_farm_lower, n_farm_coef, n_farm_upper, pct_male_lower, pct_male_coef,pct_male_upper, interaction_lower, interaction_coef, interaction_upper), decimals = 4)



# save the gt table as a png file so that you can use magick on it with a plot

#gtsave(data = maleedu_gt, filename = "final/maleedu_gt.png")


# INCORPORATE
# Effect of gender on enrollment dwindles over time
maleedu_plot <- maleedu_model %>%
  ungroup() %>%
  select(YEAR, pct_male_coef, pct_male_upper, pct_male_lower) %>%
  mutate(YEAR = as.factor(YEAR)) %>%
  group_by(YEAR) %>%
  ggplot(aes(x = YEAR, y = pct_male_coef)) + 
  geom_errorbar(ymin = maleedu_model$pct_male_lower, ymax = maleedu_model$pct_male_upper, color = "#453781FF") + 
  geom_point(color = "#440154FF") +
  theme_classic() +
  ylim(-1.5, 0.5) + 
  labs(x = "Year",
       y = "Coefficient",
       title = "Percent Male Coefficients Over Time",
       subtitle = "Measuring the effect of being male\non school enrollment")

#ggsave("final/maleedu_plot.png", plot = maleedu_plot)


cows_size_model <- allData %>%
  select(YEAR, pct_enrolled, cows_per_farm, avg_size) %>%
  na.omit() %>%
  lm(pct_enrolled ~ cows_per_farm*avg_size, data = .) %>%
  tidy(conf.int = TRUE)

#saveRDS(cows_size_model, "final/cows_size_model.rds")


# INCORPORATE
# more cows = more enrollment
cowedu_model <- allData %>%
  select(YEAR, pct_enrolled, cows_per_farm, avg_value_implements) %>%
  na.omit() %>%
  lm(pct_enrolled ~ cows_per_farm*avg_value_implements, data = .) %>%
  tidy(conf.int = TRUE) 

#saveRDS(cowedu_model, "final/cowedu_model.rds")
  
cowedu_gt <- cowedu_model %>%
  select(term, conf.low, estimate, conf.high) %>%
  gt() %>%
  tab_header(title = "Effect Cows and Implements on Enrollment",
             subtitle = "With 95% Confidence Interval") %>%
  cols_label(term = "Coefficient Name", conf.low = "Lower Bound", estimate = "Estimated Value", conf.high = "Upper Bound") %>%
  fmt_number(columns = vars(conf.low, estimate, conf.high), decimals = 4)


#gtsave(data = cowedu_gt, filename = "final/cowedu_gt.png")

# cow plot
# incorporate
cowedu_plot <- allData %>%
  select(YEAR, pct_enrolled, cows_per_farm) %>%
  na.omit() %>%
  mutate(YEAR = as.factor(YEAR)) %>%
  group_by(YEAR) %>%
  ggplot(aes(x = cows_per_farm, y = pct_enrolled, color = YEAR)) +
  geom_point(alpha = 0.1) +
  geom_smooth(method = "lm", se = FALSE) +
  scale_color_viridis_d() +
  ylim(0, 45) +
  scale_x_log10(labels = comma) +
  labs(title = "Cows and Education",
       subtitle = "Relationship between the number of cows per farm\nand school enrollment, by county",
       x = "Average Cows per Farm",
       y = "Percent of Population Enrolled in School") +
  theme_classic()

#ggsave("final/cowedu_plot.png", plot = cowedu_plot)

```

```{r farmTrends, cache=TRUE}
# this takes foever--cache it

# INCORPORATE 
# just the gif files, not the whole code
# takes too long

# Trends in Midwestern Farming over Time

plot1a <- allData %>%
  select(YEAR, STATE, acres_farms, n_farm) %>%
  na.omit() %>%
  group_by(STATE, YEAR) %>%
  summarize(mean_acres = mean(acres_farms), mean_farm = mean(n_farm)) %>%
  ggplot(aes(x = YEAR, y = mean_acres, fill = STATE)) +
  geom_col() + 
  scale_fill_viridis_d() +
  labs(x = "Year",
       y = "Mean Acreage (Cumulative)",
       title = "Average Farmland Acreage over Time",
       fill = "State") +
  theme_classic() + 
  transition_states(YEAR, wrap = FALSE) +
  shadow_mark()

#anim_save("final/plot1a.gif", plot1a)


plot1b_prep <- allData %>%
  select(YEAR, STATE, n_farm) %>%
  na.omit() %>%
  group_by(STATE, YEAR)

plot1b <- aggregate(plot1b_prep$n_farm, by = list(plot1b_prep$STATE, 
                                                  plot1b_prep$YEAR), FUN=sum) %>%
    mutate(STATE = Group.1, YEAR = Group.2, n = x) %>%
  ggplot(aes(x = YEAR, y = n, color = STATE)) +
  geom_line() + 
  scale_fill_viridis_d(aesthetics = "color") +
  labs(x = "Year",
       y = "Number of Farms",
       title = "Number of Farms over Time, by State",
       subtitle = "The number of farms increases from 1870 to the early 1900s, but is in decline by 1930",
       color = "State") +
    theme_classic() + 
    # animate
    transition_reveal(YEAR)
    
#anim_save("final/plot1b.gif", plot1b)

# States are gaining more implements each year
plot2 <- allData %>%
  mutate(YEAR = as.factor(YEAR)) %>%
  select(YEAR, STATE, value_implements) %>%
  na.omit() %>%
  group_by(YEAR, STATE) %>%
  summarize(mean_imp = mean(value_implements)) %>% 
  ungroup() %>%
  group_by(STATE) %>%
  ggplot(aes(x = YEAR, y = mean_imp, fill = STATE)) + 
  geom_col() +
  scale_fill_viridis_d() +
  labs(title = "Implement Value by Year, by State",
       subtitle = "Dollar Values Adjusted for Inflation",
       x = "Year",
       y = "Average Value of All Implements",
       fill = "State") +
  theme_classic() + 
  transition_states(YEAR, wrap = FALSE) +
  shadow_mark()

#anim_save("final/plot2.gif", plot2)


# Incorporate
# population plot

plot3_prep <- allData %>%
  select(YEAR, STATE, pop) %>%
  na.omit() %>%
  group_by(STATE, YEAR)

plot3 <- aggregate(plot3_prep$pop, by = list(plot3_prep$STATE, 
                                                  plot3_prep$YEAR), FUN=sum) %>%
    mutate(STATE = Group.1, YEAR = Group.2, n = x) %>%
  ggplot(aes(x = YEAR, y = n, color = STATE)) +
  geom_line() + 
  scale_fill_viridis_d(aesthetics = "color") +
  labs(x = "Year",
       y = "Population",
       title = "Midwest Population over Time, by State",
       color = "State") +
    theme_classic() + 
    # animate
    transition_reveal(YEAR)
    
#anim_save("final/plot3.gif", plot3)


# Urbanization plot
# Urban = 2,500+

plot4_prep <- allData %>%
  select(YEAR, pop, urban_pop) %>%
  na.omit() %>%
  mutate(pop = pop-urban_pop)

plot4_prepb <- aggregate(plot4_prep$pop, by = list(plot4_prep$YEAR), 
                   FUN=sum) %>%
  mutate(YEAR = Group.1, n_pop = x)

plot4_prepc <- aggregate(plot4_prep$urban_pop, by = list(plot4_prep$YEAR), 
                   FUN=sum) %>% 
  mutate(YEAR = Group.1, n_urban_pop = x)

# I was having trouble with the foreign package, so I commented out all code that requires it

#plot4_prepd <- full_join(plot4_prepb, plot4_prepc, by = c("YEAR")) %>%
  #select(YEAR, n_pop, n_urban_pop) %>%
  #mutate(YEAR = as.factor(YEAR)) %>%
  # convert to long format
  #melt(id="YEAR")

limits4 <- c("1", "2", "3", "4", "5", "6", "7")
labels4 <- c("1870", "1880", "1890", "1910", "1920", "1930", "1950")

#plot4 <- as_tibble(plot4_prepd) %>%
  # as.numeric is changing years to numbers 1:7
  #mutate(YEAR = as.numeric(YEAR), variable = as.character(variable), 
         #value = value/1000) %>%
  #ggplot(aes(YEAR, value, color = variable)) +
  #geom_line() +
  #scale_x_discrete(limits = limits4, labels = labels4) +
  #scale_fill_viridis_d(aesthetics = "color", breaks=c("n_urban_pop", "n_pop"), labels = c("Urban", "Rural")) +
  #labs(x = "Year",
       #y = "Population (in thousands)",
       #title = "Midwest Urbanization",
       #subtitle = "Rural and urban populations over Time",
       #color = "") +
  #theme_classic() +
  #geom_point(aes(group = seq_along(YEAR))) +
  #transition_reveal(YEAR)
    
#anim_save("final/plot4.gif", plot4)
```

# magick code

```{r magick}

```
# Combined plots using magick

# Farmland acreage & number of farms plots

mgif_1a <- image_read("final/plot1a.gif")
mgif_1b <- image_read("final/plot1b.gif")

acre_gif <- image_append(c(mgif_1a[1], mgif_1b[1]))
for(i in 2:100){
  combined <- image_append(c(mgif_1a[i], mgif_1b[i]))
  acre_gif <- c(acre_gif, combined)
}

anim_save("final/acre_gif.gif", acre_gif)


# Urbanization population plots

mgif_3 <- image_read("final/plot3.gif")
mgif_4 <- image_read("final/plot4.gif")

pop_gif <- image_append(c(mgif_3[1], mgif_4[1]))
for(i in 2:100){
  combined <- image_append(c(mgif_3[i], mgif_4[i]))
  pop_gif <- c(pop_gif, combined)
}

anim_save("final/pop_gif.gif", pop_gif)

# New Dataset for Mapping

```{r mwData-shapefile-merger}

# Ultimately, this didn't work
# I'm giving up and saving individual leaflets as 

# NEW tibble
# columns: COUNTYA?, YEAR, variable, value

# Plan: make the huge sf object for each variable from 1870-1890
# bind all the rows
# it will be huge
# save as rds
# read in at the beginning, just filter by year and variable, which now each have their own column
# figure out how to get widgets to work

mapData1 <- mwData %>% pivot_longer(cols = "Value of Farms":"Illiteracy Rate", names_to = "Variable")

mapData <- left_join(mapData1, shapefiles, by = c("YEAR" = "Year")) %>%
  
  # Only do the first three decades
  # Shiny doesn't give you enough space to upload the rest anyway
  
  filter(YEAR == "1870" | YEAR == "1880" | YEAR == "1890")

```

```{r}
year <- 1870

#choices for myvar will be determined by: 
appPlan <- mwData %>%
  filter(YEAR == year) %>%
  select_if(~ !all(is.na(.))) %>%
  select(-STATEA:-COUNTY)

# myvar options will be determined by column names of appPlan & displayed via dropdown widget
myvar <- "Value of Farms"

datayear <- mapData %>%
  # use get() to use the stored variable
  # idk why, but it doesn't work without this
  # the variable must be converted to a double in the original mwData dataset
  filter(YEAR == year, Variable == myvar) %>%
  select(GISJOIN, YEAR, Variable, value, Dsn, Layer)

# Import Census Tract Shapefile into R as SpatialPolygonsDataFrameFormat (SP Dataframe)
# dsn is location of folder which contains shapefiles, (.proj, .shp etc.)
# layer is the filename of the .shp file inside the
# folder dsn points to. 

dsnyear <- datayear %>% 
  slice(1) %>% 
  pull(Dsn)

layeryear <- datayear %>% 
  slice(1) %>% 
  pull(Layer)

countyyear <- sf::st_read(dsn = dsnyear,
                         layer = layeryear)
# IN PROGRESS, START HERE
# make a huge sf object that has all of the info
# save as RDS
# use only one filter (for year and variable) with the code calling the palette and below

countyyear <-
  countyyear %>%
  merge(datayear, "GISJOIN")

# wow you can save sf objects as RDS files, apparently!
# do this once you have everything done
# but then again, if I can save this as an RDS, do I actually need to pivot longer? does that make sense?
#saveRDS(countyyear, file = "testSfObj.rds")

# Set projection of tracts dataset to `projection` required by leaflet

countyyear <- sf::st_transform(countyyear, crs="+init=epsg:4326")

# Condense size of data for faster processing

countyyear1 <- rmapshaper::ms_simplify(countyyear)

# Set palette color

pal <- colorNumeric("viridis", NULL)

#  Plot the data

# use shiny to add a title, which will be be equivalent to myvar

leaflet(countyyear) %>%
  addTiles() %>%
  addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 1,
              fillColor = ~pal(value)) %>%
  addLegend(pal = pal, values = ~value, opacity = 1.0, title = myvar)
```

```{r}
year <- 1870

# myvar options will be determined by column names of appPlan & displayed via dropdown widget
myvar <- "Average Farm Value"

datayear <- mapData %>%
  # use get() to use the stored variable
  # idk why, but it doesn't work without this
  # the variable must be converted to a double in the original mwData dataset
  filter(YEAR == year) %>%
  select(GISJOIN, YEAR, Variable, value, Dsn, Layer)

# Import Census Tract Shapefile into R as SpatialPolygonsDataFrameFormat (SP Dataframe)
# dsn is location of folder which contains shapefiles, (.proj, .shp etc.)
# layer is the filename of the .shp file inside the
# folder dsn points to. 

dsnyear <- datayear %>% 
  slice(1) %>% 
  pull(Dsn)

layeryear <- datayear %>% 
  slice(1) %>% 
  pull(Layer)

countyyear <- sf::st_read(dsn = dsnyear,
                         layer = layeryear)

# make a huge sf object that has all of the info
# save as RDS
# use only one filter (for year and variable) with the code calling the palette and below

countyyear <-
  countyyear %>%
  merge(datayear, "GISJOIN")

# wow you can save sf objects as RDS files, apparently!
# do this once you have everything done
# but then again, if I can save this as an RDS, do I actually need to pivot longer? does that make sense?
#saveRDS(countyyear, file = "testSfObj.rds")

# Set projection of tracts dataset to `projection` required by leaflet

countyyear <- sf::st_transform(countyyear, crs="+init=epsg:4326")

# Condense size of data for faster processing
# This is taking too long to run; session encounters a fatal error
# What if I simplify after filtering?
# countyyear <- rmapshaper::ms_simplify(countyyear)

countyear <- countyyear %>%
  filter(Variable == myvar)

countyyear <- rmapshaper::ms_simplify(countyyear)

pal <- colorNumeric("viridis", NULL)

#  Plot the data

# use shiny to add a title, which will be be equivalent to myvar

leaflet(countyyear) %>%
  addTiles() %>%
  addPolygons(stroke = FALSE, smoothFactor = 0.3, fillOpacity = 1,
              fillColor = ~pal(value)) %>%
  #setView(-87.4290, 43, zoom = 6) %>%
  addLegend(pal = pal, values = ~value, opacity = 1.0, title = myvar)
  

```

